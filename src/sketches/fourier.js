const s = (p) => {

    //Discrete Fourier Transform

    let c = []

    let F = null

    const len = 50

    let time = 0

    let path = []

    let userDrawing = []


    p.mouseDragged = () => {
        userDrawing.push(p.createVector(p.mouseX - p.width / 2, p.mouseY - p.height / 2))
    }

    p.mouseReleased = () => {
        computeUserPath()
        reset(true)
    }

    function computeUserPath() {
        F = dft(userDrawing)
        F.sort((a, b) => b.amp - a.amp)
    }

    function reset(resetUserDrawing = false) {
        if (resetUserDrawing) {
            userDrawing = []
        }
        path = []
        time = 0
    }

    p.setup = () => {
        p.createCanvas(600, 600)
        //create initial F from path generated by perlin noise
        for (let i = 0; i < len; i++) {
            const a = p.map(i, 0, len, 0, p.TWO_PI)
            c[i] = p.createVector(
                100 * p.noise(a), 100 * p.noise(a + 1000)
            )
        }
        //compute DFT
        F = dft(c)
        F.sort((a, b) => b.amp - a.amp)
    }

    p.draw = () => {
        p.background(250)

        if (!p.mouseIsPressed) {
            const v = epicycle(p.width / 2, p.height / 2, F, 0)

            path.unshift(v)

            p.stroke(0)
            p.noFill()
            p.beginShape()
            path.forEach(v => p.vertex(v.x, v.y))
            p.endShape()

            //time speed
            const dt = p.TWO_PI / F.length
            //animation scale speed
            const fc = p.frameCount % 2 === 0
            //increment time
            if (fc) {
                time += dt
            }
            if (time > p.TWO_PI) {
                reset()
            }

        } else {
            p.beginShape()
            userDrawing.forEach(v => p.vertex(v.x + p.width / 2, v.y + p.width / 2))
            p.endShape()
        }

    }

    function epicycle(x, y, f, rot) {
        for (let i = 0; i < f.length; i++) {

            const prevx = x
            const prevy = y

            const freq = f[i].freq
            const rad = f[i].amp
            const phase = f[i].phase


            x += rad * p.cos(freq * time + phase + rot)
            y += rad * p.sin(freq * time + phase + rot)

            p.stroke(0, 80)
            p.noFill()
            p.circle(prevx, prevy, 2 * rad)

            p.stroke(0, 160)
            p.line(prevx, prevy, x, y)
        }
        return p.createVector(x, y)
    }

    const dft = (x) => {
        const X = []
        const N = x.length

        for (let k = 0; k < N; k++) {
            let sum = p.createVector(0, 0)
            for (let n = 0; n < N; n++) {
                let phi = (p.TWO_PI * k * n) / N
                const c = p.createVector(p.cos(phi), -p.sin(phi))
                sum.add(cmult(x[n], c))
            }
            sum.div(N)

            const freq = k
            const amp = sum.mag()
            const phase = p.atan2(sum.y, sum.x)

            X[k] = {
                r: sum.x,
                i: sum.y,
                freq,
                amp,
                phase
            }
        }
        console.log('epicycles count :: ', X.length)
        return X
    }

    function cmult(a, b) {
        const r = a.x * b.x - a.y * b.y
        const i = a.x * b.y + a.y * b.x
        return p.createVector(r, i)
    }
}

export default s